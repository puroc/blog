<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[camel知识点-管理和监控]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-并行处理]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-事务处理]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-错误处理]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-自定义组件]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-表达式语言]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-类型转换]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-组件]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-核心概念]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[camel知识点-目录]]></title>
    <url>%2Fblog%2F2019%2F02%2F18%2Fcamel%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[camel知识点-核心概念camel知识点-组件camel知识点-类型转换camel知识点-表达式语言camel知识点-自定义组件camel知识点-错误处理camel知识点-事务处理camel知识点-并行处理camel知识点-管理和监控]]></content>
      <categories>
        <category>camel知识点</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-Greenplum]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-Greenplum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-分库分表]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-读写分离]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-分区]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-SQL优化]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-SQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-事务]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-锁]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-索引]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-视图]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-DML-数据查询]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-DML-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-DML-数据操纵]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-DML%2F</url>
    <content type="text"><![CDATA[文档链接 1、插入数据向如下产品表插入数据 12345CREATE TABLE products ( product_no integer, name text, price numeric); 插入一行数据，数据的值是按照这些列在表中出现的顺序列出的。 1INSERT INTO products VALUES (1, &apos;Cheese&apos;, 9.99); 指定列的顺序进行插入 12INSERT INTO products (product_no, name, price) VALUES (1, &apos;Cheese&apos;, 9.99);INSERT INTO products (name, price, product_no) VALUES (&apos;Cheese&apos;, 9.99, 1); 插入数据时使用缺省值 以下第二种形式是PostgreSQL的一个扩展。它从使用给出的值从左开始填充列，有多少个给出的列值就填充多少个列，其他列的将使用缺省值。 12INSERT INTO products (product_no, name) VALUES (1, &apos;Cheese&apos;);INSERT INTO products VALUES (1, &apos;Cheese&apos;); 一次插入多行 1234INSERT INTO products (product_no, name, price) VALUES (1, &apos;Cheese&apos;, 9.99), (2, &apos;Bread&apos;, 1.99), (3, &apos;Milk&apos;, 2.99); 也可以插入查询的结果（可能没有行、一行或多行） 123INSERT INTO products (product_no, name, price) SELECT product_no, name, price FROM new_products WHERE release_date = &apos;today&apos;; 2、更新数据1UPDATE products SET price = 10 WHERE price = 5; 新的列值可以是任意标量表达式， 而不仅仅是常量。 1UPDATE products SET price = price * 1.10; 一次更新多列 1UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a &gt; 0; 3、删除数据1DELETE FROM products WHERE price = 10; 4、从修改的行中返回数据 RETURNING可以返回分配给新行的ID 123CREATE TABLE users (firstname text, lastname text, id serial primary key);INSERT INTO users (firstname, lastname) VALUES (&apos;Joe&apos;, &apos;Cool&apos;) RETURNING id; 在UPDATE中，可用于RETURNING的数据是被修改行的新内容 123UPDATE products SET price = price * 1.10 WHERE price &lt;= 99.99 RETURNING name, price AS new_price; 在DELETE中，可用于RETURNING的数据是删除行的内容 123DELETE FROM products WHERE obsoletion_date = &apos;today&apos; RETURNING *;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-DDL]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-DDL%2F</url>
    <content type="text"><![CDATA[全文目录 1、数据库管理1.1、创建数据库语法文档连接 例子：1CREATE DATABASE lusiadas; 1234CREATE DATABASE music2 LC_COLLATE &apos;sv_SE.iso885915&apos; LC_CTYPE &apos;sv_SE.iso885915&apos; ENCODING LATIN9 TEMPLATE template0; 1.2、修改数据库语法文档连接 例子1ALTER DATABASE test SET enable_indexscan TO off; 1.3、删除数据库语法1DROP DATABASE [ IF EXISTS ] name 参数说明IF EXISTS：删除数据库时，如果数据库不存在，也不会抛出错误 例子1DROP DATABASE IF EXISTS music2; 2、表管理2.1、创建表语法文档连接 例子文档连接 1、默认值在一个表定义中，默认值被列在列的数据类型之后。例如： 12345CREATE TABLE products ( product_no integer, name text, price numeric DEFAULT 9.99); 默认值可以是一个表达式，它将在任何需要插入默认值的时候被实时计算（不是表创建时）。一个常见的例子是为一个timestamp列指定默认值为CURRENT_TIMESTAMP，这样它将得到行被插入时的时间。另一个常见的例子是为每一行生成一个“序列号” 。这在PostgreSQL可以按照如下方式实现：这里nextval()是函数 1234CREATE TABLE products ( product_no integer DEFAULT nextval(&apos;products_product_no_seq&apos;), ...); 2、检查约束检查约束有列约束和表约束两种用法。列约束例子如下，如你所见，约束定义就和默认值定义一样跟在数据类型之后。 12345CREATE TABLE products ( product_no integer, name text, price numeric CHECK (price &gt; 0)); 表约束例子如下，其中第三个约束使用了一种新语法。它并没有依附在一个特定的列，而是作为一个独立的项出现在逗号分隔的列表中，这就是表检查约束。 1234567CREATE TABLE products ( product_no integer, name text, price numeric CHECK (price &gt; 0), discounted_price numeric CHECK (discounted_price &gt; 0), CHECK (price &gt; discounted_price)); 3、非空约束非空约束指定一个列中不会有空值 12345CREATE TABLE products ( product_no integer NOT NULL, name text NOT NULL, price numeric); 一个列可以有多于一个的约束，只需要将这些约束一个接一个写出，约束的顺序没有关系。 12345CREATE TABLE products ( product_no integer NOT NULL, name text NOT NULL, price numeric NOT NULL CHECK (price &gt; 0)); 4、唯一约束唯一约束保证\在一列中或者一组列中保存的数据在表中所有行间是唯一的 12345CREATE TABLE products ( product_no integer UNIQUE, name text, price numeric); 要为一组列定义一个唯一约束，把它写作一个表级约束，列名用逗号分隔 123456CREATE TABLE example ( a integer, b integer, c integer, UNIQUE (a, c)); 注意：1）如果表中有超过一行在约束所包括列上的值相同，将会违反唯一约束。但是在这种比较中，两个空值被认为是不同的。2）增加一个唯一约束会在约束中列出的列或列组上自动创建一个唯一B-tree索引 5、主键一个主键约束表示可以用作表中行的唯一标识符的一个列或者一组列。这要求那些值都是唯一的并且非空 12345CREATE TABLE products ( product_no integer PRIMARY KEY, name text, price numeric); 主键也可以包含多于一个列 123456CREATE TABLE example ( a integer, b integer, c integer, PRIMARY KEY (a, c)); 注意：1) 增加一个主键将自动在主键中列出的列或列组上创建一个唯一B-tree索引 6、外键一个外键约束指定一列（或一组列）中的值必须匹配出现在另一个表中某些行的值。例如我们有一个使用过多次的产品表： 12345CREATE TABLE products ( product_no integer PRIMARY KEY, name text, price numeric); 让我们假设我们还有一个存储这些产品订单的表。我们希望保证订单表中只包含真正存在的产品的订单。因此我们在订单表中定义一个引用产品表的外键约束，现在就不可能创建包含不存在于产品表中的product_no值（非空）的订单。在这种情况下，订单表是引用表而产品表是被引用表。 12345CREATE TABLE orders ( order_id integer PRIMARY KEY, product_no integer REFERENCES products (product_no), quantity integer); 一个外键也可以约束和引用一组列。照例，它需要被写成表约束的形式。当然被约束列的数量和类型应该匹配被引用列的数量和类型。下面是一个例子： 123456CREATE TABLE t1 ( a integer PRIMARY KEY, b integer, c integer, FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)); 我们知道外键不允许创建与任何产品都不相关的订单。但如果一个产品在一个引用它的订单创建之后被移除会发生什么？SQL允许我们处理这种情况。直观上，我们有几种选项： 不允许删除一个被引用的产品 同时也删除引用产品的订单 其他？ 为了说明这些，让我们在上面的多对多关系例子中实现下面的策略：当某人希望移除一个仍然被一个订单引用（通过order_items）的产品时 ，我们组织它。如果某人移除一个订单，订单项也同时被移除： 123456789101112131415161718CREATE TABLE products ( product_no integer PRIMARY KEY, name text, price numeric);CREATE TABLE orders ( order_id integer PRIMARY KEY, shipping_address text, ...);CREATE TABLE order_items ( product_no integer REFERENCES products ON DELETE RESTRICT, order_id integer REFERENCES orders ON DELETE CASCADE, quantity integer, PRIMARY KEY (product_no, order_id)); 限制删除或者级联删除是两种最常见的选项。RESTRICT阻止删除一个被引用的行。NO ACTION表示在约束被检察时如果有任何引用行存在，则会抛出一个错误，这是我们没有指定任何东西时的默认行为（这两种选择的本质不同在于NO ACTION允许检查被推迟到事务的最后，而RESTRICT则不会）。CASCADE指定当一个被引用行被删除后，引用它的行也应该被自动删除。还有其他两种选项：SET NULL和SET DEFAULT。这些将导致在被引用行被删除后，引用行中的引用列被置为空值或它们的默认值。注意这些并不会是我们免于遵守任何约束。例如，如果一个动作指定了SET DEFAULT，但是默认值不满足外键约束，操作将会失败。 与ON DELETE相似，同样有ON UPDATE可以用在一个被引用列被修改（更新）的情况，可选的动作相同。在这种情况下，CASCADE意味着被引用列的更新值应该被复制到引用行中。 正常情况下，如果一个引用行的任意一个引用列都为空，则它不需要满足外键约束。如果在外键定义中加入了MATCH FULL，一个引用行只有在它的所有引用列为空时才不需要满足外键约束（因此空和非空值的混合肯定会导致MATCH FULL约束失败）。如果不希望引用行能够避开外键约束，将引用行声明为NOT NULL。 一个外键所引用的列必须是一个主键或者被唯一约束所限制。这意味着被引用列总是拥有一个索引（位于主键或唯一约束之下的索引），因此在其上进行的一个引用行是否匹配的检查将会很高效。由于从被引用表中DELETE一行或者UPDATE一个被引用列将要求对引用表进行扫描以得到匹配旧值的行，在引用列上建立合适的索引也会大有益处。由于这种做法并不是必须的，而且创建索引也有很多种选择，所以外键约束的定义并不会自动在引用列上创建索引。 2.2、修改表语法文档连接 例子要向一个表增加一个类型为varchar的列： 1ALTER TABLE distributors ADD COLUMN address varchar(30); 要从表中删除一列： 1ALTER TABLE distributors DROP COLUMN address RESTRICT; 要在一个操作中更改两个现有列的类型： 123ALTER TABLE distributors ALTER COLUMN address TYPE varchar(80), ALTER COLUMN name TYPE varchar(100); 2.3、删除表语法文档连接 例子1DROP TABLE IF EXISTS films, distributors; 3、数据类型文档连接 1、数字类型 2、字符类型 3、日期时间类型 4、JSON类型5、数组类型]]></content>
      <categories>
        <category>数据库知识点</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点-目录]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[参考文献：PostgreSQL10中文文档PostgreSQL10官方文档SQL语法 1、DDL2、DML 2.1 数据操纵 2.2 数据查询 3、视图4、索引5、锁6、事务7、性能优化 7.1 SQL优化 7.2 分区 7.3 读写分离 7.4 分库分表 7.5 Greenplum]]></content>
      <categories>
        <category>数据库知识点</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇语]]></title>
    <url>%2Fblog%2F2019%2F01%2F29%2F%E5%BC%80%E7%AF%87%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
</search>
